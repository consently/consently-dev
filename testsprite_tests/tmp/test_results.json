[
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "ab63e78c-94d9-47ff-88ff-19fb2c32ea9c",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC001-User Registration with Email Verification",
    "description": "Verify that a new user can register using a valid email and password and complete email verification to activate the account.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Account Activation Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The user registration and email verification process did not complete successfully as expected in the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The landing page is currently showing an Internal Server Error, preventing access to the registration process. The new user registration and email verification cannot be tested until this issue is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/176311702278429//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.919Z",
    "modified": "2025-11-14T10:43:42.931Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "6703d8c3-2768-4f89-a96a-df05ae28fbf6",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC002-User Login with Email/Password",
    "description": "Ensure existing users can login successfully with valid email and password credentials.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Login Successful! Welcome to your Dashboard').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User was not authenticated and redirected to Dashboard as expected after login with valid credentials.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The landing page is returning an Internal Server Error, preventing navigation to the login page and thus blocking the login test. Please fix the server error to proceed with login testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117035786994//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.927Z",
    "modified": "2025-11-14T10:43:55.904Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "a49c021c-926e-4a4b-b127-14b96b49792b",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC003-User Login with OAuth Providers",
    "description": "Verify login functionality using supported OAuth providers such as Google and Microsoft.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful! Welcome to Your Dashboard').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User was not authenticated and taken to Dashboard after completing OAuth login flow with Google.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The login functionality test using OAuth providers such as Google and Microsoft could not be completed because the main page returned an Internal Server Error. The issue has been reported. Please resolve the server error and retry the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117033548563//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.933Z",
    "modified": "2025-11-14T10:43:53.678Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "0977a9cd-77d5-46f8-a560-1a3a4a606f38",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC004-Password Reset Functionality",
    "description": "Ensure users can request a password reset email and successfully reset their password.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Password Reset Successful! Welcome Back').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Password reset process did not complete successfully as per the test plan. User was unable to login with the new password.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The password reset flow cannot be tested because the website at http://localhost:3000/ is currently showing an Internal Server Error. The issue has been reported. Please resolve the server error to proceed with testing the password reset functionality.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/176311703384185//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.939Z",
    "modified": "2025-11-14T10:43:53.963Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "64c771bf-6593-44bd-8d42-9ba59fa71d13",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC005-Dashboard Loading and Sidebar Navigation",
    "description": "Verify that after login, the Dashboard loads with metrics overview and sidebar navigation works correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful and Dashboard Loaded').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Dashboard did not load correctly after login, or sidebar navigation did not work as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The initial page shows an Internal Server Error, preventing login and further testing. The task cannot proceed until the server issue is resolved.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117023407783//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.945Z",
    "modified": "2025-11-14T10:43:43.526Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "404be7fe-f50f-4cf5-90f1-1d5faeadc67d",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC006-Automated Cookie Scanning with Accurate Classification",
    "description": "Validate that the cookie scanning feature scans the website, classifies cookies with over 95% accuracy, and displays results for review and saving.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=No Cookies Found or Classification Failed').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The cookie scanning feature did not scan the website, classify cookies with over 95% accuracy, or display results for review and saving as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The website at http://localhost:3000/ shows an Internal Server Error, preventing any interaction or testing of the cookie scanning feature. The issue has been reported. Task cannot proceed further.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117035199039//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.952Z",
    "modified": "2025-11-14T10:43:55.363Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "90b292c9-203b-4803-ab31-d6efc13cea74",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC007-Cookie Banner Customization and Widget Deployment",
    "description": "Confirm that users can customize cookie banners, preview changes, generate banner code, and deploy widget correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Cookie Banner Customization Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution did not complete successfully. Users could not confirm customization, preview, code generation, or deployment of the cookie banner widget as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to confirm customization, preview, code generation, and deployment of cookie banners could not be completed because the main website at http://localhost:3000/ shows an Internal Server Error. This error prevents access to the dashboard and all related functionalities. Please resolve the server error to proceed with testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117035473711//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.958Z",
    "modified": "2025-11-14T10:43:55.616Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "1f929e5d-e4f5-4f43-99cb-f46e324b6404",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC008-DPDPA Consent Processing Activities Setup with Industry Templates",
    "description": "Test setup of data processing activities using pre-built industry-specific templates and manual adjustments.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Industry Template Applied Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution failed because the template processing activities did not populate correctly or saved activities were not persisted and retrievable as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The testing task for setting up data processing activities using pre-built industry-specific templates and manual adjustments could not be completed due to an Internal Server Error on the main page (http://localhost:3000/). The issue has been reported. Please resolve the server error and retry the testing process.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117035194413//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.966Z",
    "modified": "2025-11-14T10:43:55.355Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "45080eb2-8b20-4541-8db9-4c731826b498",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC009-DPDPA Consent Widget Configuration and Consent Collection",
    "description": "Validate configuration of the DPDPA consent widget, code generation, embedding, and end-user granular consent collection.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=DPDPA Consent Widget Successfully Configured').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The DPDPA consent widget configuration, embedding, or granular consent collection did not complete successfully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to Internal Server Error on the test site. Cannot proceed with widget configuration validation, embedding, or end-user consent testing until the site is fixed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117030767419//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.973Z",
    "modified": "2025-11-14T10:43:50.890Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "34d9626a-97d9-4d29-b11f-565c3b91c559",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC010-Consent ID Verification and Cross-Device Preference Sync",
    "description": "Ensure end-users can verify their Consent ID on a new device and previously given preferences load correctly with error handling.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Consent ID verification successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Unable to verify Consent ID on a new device and load user preferences correctly as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed due to Internal Server Error on the main page for Consent ID verification input. Please resolve the server issue before retrying.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117030256592//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.979Z",
    "modified": "2025-11-14T10:43:50.369Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "21c588ea-fd88-4cf8-ab69-47f267151a8b",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC011-Analytics Dashboard with Filtering and Data Export",
    "description": "Test that real-time consent trends, device and geographic breakdowns display correctly and reports export in supported formats.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Export Successful! Your report is ready').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Real-time consent trends, device and geographic breakdowns did not display correctly, or report export encountered errors as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing could not be completed because the main page returned an Internal Server Error. The issue has been reported. Please resolve the server error to proceed with testing real-time consent trends, device and geographic breakdowns, and report exports.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117032615641//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.985Z",
    "modified": "2025-11-14T10:43:52.729Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "5dac4a86-0320-4c63-acee-86e9b8329da2",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC012-Audit Trail Viewing and Export",
    "description": "Verify complete audit logs can be searched by criteria and exported as compliance reports in multiple formats.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Audit log export successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The audit log export did not complete successfully as required by the test plan to verify complete audit logs can be searched and exported as compliance reports.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The audit log search and export task could not be completed because the main application page returned an Internal Server Error, preventing access to the dashboard and audit features. The issue has been reported.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117034041511//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.991Z",
    "modified": "2025-11-14T10:43:54.185Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "87adc95c-6aa0-4294-9e5f-8d67403c80e9",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC013-Privacy Centre Consent Management and Data Subject Rights Requests",
    "description": "Test that end-users can access Privacy Centre, manage their consents, and submit data subject rights requests successfully.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Denied to Privacy Centre').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The Privacy Centre could not be accessed or did not load correctly, preventing users from managing consents and submitting data subject rights requests as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to Internal Server Error on the Privacy Centre landing page. Cannot proceed with consent management or data subject rights requests testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117031311516//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:20.997Z",
    "modified": "2025-11-14T10:43:51.440Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "7a28e811-0e03-4fd1-84f7-916f1f105c5e",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC014-Settings Profile Update and Security 2FA Enablement",
    "description": "Validate updating user profile details and enabling/disabling two-factor authentication from settings.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Profile update successful and 2FA enabled').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The user profile details update and two-factor authentication enabling did not complete successfully as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The task to validate updating user profile details and enabling/disabling two-factor authentication could not be completed because the application landing page shows an Internal Server Error. The issue has been reported. Please resolve the server error to proceed with testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117033311468//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.004Z",
    "modified": "2025-11-14T10:43:53.426Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "3a2086c5-204f-49b0-a199-2302affa4061",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC015-Subscription Payment Processing via Razorpay",
    "description": "Confirm subscriptions can be purchased using Razorpay with successful payment and invoice generation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Subscription Purchase Complete').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Subscription purchase using Razorpay did not complete successfully, or invoice was not generated as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The subscription purchase test could not be completed because the website at http://localhost:3000/ is showing an Internal Server Error. Therefore, it was not possible to navigate to the Dashboard, select a subscription plan, complete Razorpay payment, or verify invoice generation. Please resolve the server error and try again.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117033798829//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.010Z",
    "modified": "2025-11-14T10:43:53.928Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "17985f95-2123-460b-ba00-23f20d6cf22b",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC016-Error Handling - Invalid Login Credentials",
    "description": "Verify system properly rejects login attempts with invalid credentials and displays appropriate error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Login Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: Login attempt with invalid credentials did not succeed as expected. The system should reject invalid login and display an error message.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The login page is currently inaccessible due to an Internal Server Error. Therefore, it was not possible to verify the system's behavior with invalid credentials or check for appropriate error messages. The issue has been reported and the test cannot proceed until the server error is fixed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117034288382//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.018Z",
    "modified": "2025-11-14T10:43:54.408Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "0fa7fb69-d870-4035-a4f0-f3614beddb30",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC017-Error Handling - Expired Email Verification Link",
    "description": "Ensure expired or invalid email verification links are handled gracefully with clear instructions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Verification Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: The email verification link is expired or invalid, but the system did not show a clear message with next steps as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The system does not handle expired or invalid email verification links gracefully. Instead, it shows an Internal Server Error. This needs to be fixed to provide clear instructions to the user.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117031280705//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.030Z",
    "modified": "2025-11-14T10:43:51.416Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "9208ffe3-a5fb-48e7-8d74-c955dcda0627",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC018-Performance - API Response Time Below 500ms",
    "description": "Validate that key API endpoints respond within 500 milliseconds under normal load conditions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Perform direct API requests to critical endpoints (authentication, consent submission, cookie scanning) to measure response times.\n        await page.goto('http://localhost:3000/api/authentication', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        await page.goto('http://localhost:3000/api/consent-submission', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        await page.goto('http://localhost:3000/api/cookie-scanning', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=API response time exceeded 500 milliseconds').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: One or more key API endpoints did not respond within 500 milliseconds under normal load conditions.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "All critical API endpoints (authentication, consent submission, cookie scanning) failed to respond correctly within 500 milliseconds under normal load conditions. The cookie scanning endpoint returned an Internal Server Error, and the other endpoints were inaccessible or did not provide response time data. Task is concluded with failure to meet the performance criteria.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/authentication:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/consent-submission:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/api/cookie-scanning:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117048733251//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.036Z",
    "modified": "2025-11-14T10:44:08.844Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "41c2e9ad-d482-4a1b-be8c-690afd04e6aa",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC019-Performance - Consent Widget Load Time Under 1 second",
    "description": "Ensure the DPDPA consent widget loads and renders fully within 1 second on supported devices and networks.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=DPDPA Consent Widget Loaded Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: The DPDPA consent widget did not load and render fully within 1 second as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The test website at http://localhost:3000/ returned an Internal Server Error, preventing the embedding and testing of the DPDPA consent widget. The issue has been reported. Unable to verify if the widget loads and renders fully within 1 second on supported devices and networks due to this error.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117035404705//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.043Z",
    "modified": "2025-11-14T10:43:55.522Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "9d65396c-ef43-4781-a8d2-a137e2adbff8",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC021-Accessibility and Localization - Multi-language Support and WCAG 2.1 AA",
    "description": "Confirm all user interfaces support switching among 22 Indian languages and conform to WCAG 2.1 AA accessibility standards.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Welcome to the Mars Colony Interface').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The UI does not support switching among all 22 Indian languages or does not conform to WCAG 2.1 AA accessibility standards as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed because the UI is not accessible due to an Internal Server Error. Please fix the server issue and retry the tests.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117031700682//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.049Z",
    "modified": "2025-11-14T10:43:51.815Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "05d06ea7-c566-432a-aaa7-10ec515ef496",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC022-Onboarding Wizard Multi-step User Flow",
    "description": "Test that new users completing onboarding wizard experience seamless navigation through all steps and final dashboard access.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Onboarding Wizard Completed Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The onboarding wizard did not complete successfully, or the final dashboard did not load as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The onboarding wizard test could not be completed because the website is currently showing an Internal Server Error on the initial page load. This prevents logging in as a new user and proceeding through the onboarding steps. The issue has been reported. Please resolve the server error and retry the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117033714842//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.060Z",
    "modified": "2025-11-14T10:43:53.832Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "3b8883c9-b12d-4b89-a994-3c39f85f9ede",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC023-Consent Data Persistence and Recovery",
    "description": "Verify that consent data is stored reliably and can be recovered accurately after logout or session expiration.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Consent Data Verified Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: Consent data was not stored reliably or could not be recovered accurately after logout or session expiration as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The test website at http://localhost:3000/ is currently showing an Internal Server Error, preventing further testing steps. Please resolve the server issue and retry the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117030076622//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.068Z",
    "modified": "2025-11-14T10:43:50.200Z"
  },
  {
    "projectId": "268e74bb-e945-4946-8a72-c4ee898aa5ff",
    "testId": "fbf56527-ce69-4896-b493-75d3a7349d62",
    "userId": "54e85438-50f1-7074-a09f-98a094612f91",
    "title": "TC024-Rate Limiting Middleware Functionality",
    "description": "Test the rate limiting middleware blocks excessive API requests and returns appropriate error codes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Rate Limit Exceeded').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The rate limiting middleware did not block excessive API requests as expected. The system did not respond with the 'Rate Limit Exceeded' error message after rapid repeated requests exceeding the allowed limit.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The rate limiting middleware test could not be performed because the API/UI at http://localhost:3000 is returning an Internal Server Error. The issue has been reported. Please resolve the server error and retry the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: the server responded with a status of 500 (Internal Server Error) (at http://localhost:3000/:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/54e85438-50f1-7074-a09f-98a094612f91/1763117031799251//tmp/test_task/result.webm",
    "created": "2025-11-14T10:43:21.078Z",
    "modified": "2025-11-14T10:43:51.917Z"
  }
]
